#!/usr/bin/env bash
set -euo pipefail

# plan-feature.sh - Transform user request into executable implementation plan
#
# Logs to: .ai/ledger/PLANNING.md (separate from LEDGER.md)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

DRY_RUN=false
INTERACTIVE=false
DEFER_ISSUE=false
REQUEST=""
EXECUTE_SCOPE="review"
SESSION_ID=$(date +%Y%m%d-%H%M%S)
START_TIME=$(date +%s)

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Transform a user request into an executable implementation plan.

Options:
    --request "text"    The feature/change request
    --execute SCOPE     Execution scope: all, p0-p1, p0, none, custom:01,02
    --defer-issue       Create GitHub issue for deferred tasks
    --dry-run           Show prompts without executing
    --interactive       Run prompts interactively
    --cleanup <dir>     Clean up ephemeral files after deployment
    -h, --help          Show this help message

Logs to: .ai/ledger/PLANNING.md (not LEDGER.md)
EOF
    exit 0
}

# Log to PLANNING.md (separate from LEDGER.md)
log_to_planning() {
    local status="$1"
    local details="$2"
    local planning_file="$REPO_ROOT/.ai/ledger/PLANNING.md"
    
    mkdir -p "$(dirname "$planning_file")"
    
    # Initialize if doesn't exist
    if [[ ! -f "$planning_file" ]]; then
        cat > "$planning_file" << 'HEADER'
# Feature Planning Log

Track feature planning sessions separately from implementation operations.

**Purpose**: Audit trail for planning decisions, not actual changes.
**Implementation log**: See `LEDGER.md` for actual operations.

## Sessions

HEADER
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - START_TIME))
    local timestamp=$(date -Iseconds)
    local request_summary=$(head -1 "$REPO_ROOT/.ai/_scratch/user-request.md" 2>/dev/null | cut -c1-60 || echo "N/A")
    
    cat >> "$planning_file" << ENTRY

---

### $timestamp - $status

| Field | Value |
|-------|-------|
| Session | \`$SESSION_ID\` |
| Duration | ${duration}s |
| Request | $request_summary... |

$details

ENTRY
}

# Create GitHub issue for deferred work
create_defer_issue() {
    local feature_dir="$1"
    local deferred_tasks="$2"
    local feature_name=$(basename "$feature_dir")
    
    echo -e "${BLUE}Creating GitHub issue for deferred work...${NC}"
    
    local issue_body=$(cat << ISSUE
## Deferred Work from Feature Planning

**Feature**: $feature_name
**Session**: $SESSION_ID
**Deferred**: $(date -Iseconds)

### Original Request
$(cat "$REPO_ROOT/.ai/_scratch/user-request.md" 2>/dev/null || echo "N/A")

### Deferred Tasks

$deferred_tasks

### Context Files

- \`$feature_dir/PDR.md\` - Technical design record
- \`$feature_dir/FEATURE.md\` - Feature specification
- \`$feature_dir/research/\` - Research artifacts

---
*Auto-generated by plan-feature.sh*
ISSUE
)
    
    if command -v gh &> /dev/null; then
        local repo_owner=$(gh repo view --json owner -q '.owner.login' 2>/dev/null || echo "")
        local repo_name=$(gh repo view --json name -q '.name' 2>/dev/null || echo "")
        
        if [[ -n "$repo_owner" ]] && [[ -n "$repo_name" ]]; then
            local issue_url=$(gh issue create \
                --title "ðŸ”® Deferred: $feature_name" \
                --body "$issue_body" \
                --label "ai-deferred,backlog" \
                2>/dev/null || echo "")
            
            if [[ -n "$issue_url" ]]; then
                echo -e "${GREEN}âœ“ Created GitHub issue: $issue_url${NC}"
                echo "$issue_url" > "$feature_dir/DEFERRED_ISSUE.txt"
                return 0
            fi
        fi
    fi
    
    echo -e "${YELLOW}GitHub CLI not available. Creating local file.${NC}"
    echo "$issue_body" > "$feature_dir/DEFERRED_WORK.md"
    echo -e "${GREEN}âœ“ Created: $feature_dir/DEFERRED_WORK.md${NC}"
}

# Initialize manifest
init_manifest() {
    local feature_dir="$1"
    cat > "$feature_dir/MANIFEST.md" << EOF
# File Manifest

**Session**: $SESSION_ID
**Created**: $(date -Iseconds)

## Files

| File | Category | Keep |
|------|----------|------|
EOF
}

track_file() {
    local feature_dir="$1"
    local file_path="$2"
    local category="$3"
    local keep="âŒ"
    [[ "$category" == "DOCS" ]] && keep="âœ…"
    echo "| \`$file_path\` | $category | $keep |" >> "$feature_dir/MANIFEST.md"
}

cleanup_feature() {
    local feature_dir="$1"
    echo -e "${BLUE}Cleaning up: $feature_dir${NC}"
    
    # Keep DOCS, delete rest
    find "$feature_dir" -name "*.log" -delete 2>/dev/null
    rm -rf "$feature_dir/research" 2>/dev/null
    rm -rf "$feature_dir/prompts" 2>/dev/null
    rm -f "$feature_dir/execute.sh" 2>/dev/null
    
    echo -e "${GREEN}âœ“ Cleanup complete. Kept: FEATURE.md, PDR.md, MANIFEST.md${NC}"
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --request) REQUEST="$2"; shift 2 ;;
        --execute) EXECUTE_SCOPE="$2"; shift 2 ;;
        --defer-issue) DEFER_ISSUE=true; shift ;;
        --dry-run) DRY_RUN=true; shift ;;
        --interactive) INTERACTIVE=true; shift ;;
        --cleanup) cleanup_feature "$2" ;;
        -h|--help) usage ;;
        *) echo "Unknown option: $1"; usage ;;
    esac
done

# Find governance
GOVERNANCE_PATH=""
[[ -d "$REPO_ROOT/.governance/ai" ]] && GOVERNANCE_PATH="$REPO_ROOT/.governance/ai"
[[ -z "$GOVERNANCE_PATH" ]] && { echo -e "${RED}Error: Governance submodule not found${NC}"; exit 1; }

BUNDLE_PATH="$GOVERNANCE_PATH/core/templates/golden-image/.ai/bundles/feature-planning-v1"
[[ ! -d "$BUNDLE_PATH" ]] && { echo -e "${RED}Error: Bundle not found${NC}"; exit 1; }

# Setup
mkdir -p "$REPO_ROOT/.ai/_scratch"
mkdir -p "$REPO_ROOT/.ai/ledger"

# Handle request
[[ -n "$REQUEST" ]] && echo "$REQUEST" > "$REPO_ROOT/.ai/_scratch/user-request.md"
[[ ! -f "$REPO_ROOT/.ai/_scratch/user-request.md" ]] && {
    echo -e "${YELLOW}Enter your request (Ctrl+D when done):${NC}"
    cat > "$REPO_ROOT/.ai/_scratch/user-request.md"
}

echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BLUE}â•‘           Feature Planning Pipeline                          â•‘${NC}"
echo -e "${BLUE}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
echo -e "${BLUE}â•‘  Session: $SESSION_ID                              â•‘${NC}"
echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

[[ "$DRY_RUN" == true ]] && { log_to_planning "DRY_RUN" "Dry run only"; exit 0; }
command -v claude &> /dev/null || { echo -e "${RED}Error: claude CLI not found${NC}"; exit 1; }

# Create feature directory
FEATURE_DIR="$REPO_ROOT/.ai/_scratch/feature-$SESSION_ID"
mkdir -p "$FEATURE_DIR/research" "$FEATURE_DIR/prompts"
init_manifest "$FEATURE_DIR"

# Phase 1: Research & Planning
echo -e "${MAGENTA}â•â•â• PHASE 1: Research & Planning â•â•â•${NC}"

for num in 00 01 02 03 04 05; do
    prompt=$(find "$BUNDLE_PATH/prompts" -name "${num}_*.md" 2>/dev/null | head -1)
    [[ -z "$prompt" ]] && continue
    
    PROMPT_NAME=$(basename "$prompt" .md)
    echo -e "${BLUE}â†’ $PROMPT_NAME${NC}"
    
    LOG_FILE="$FEATURE_DIR/${PROMPT_NAME}.log"
    if claude -p "$(cat "$prompt")" --allowedTools Edit,Write,Bash 2>&1 | tee "$LOG_FILE"; then
        track_file "$FEATURE_DIR" "$LOG_FILE" "LOGS"
        echo -e "${GREEN}âœ“${NC}"
    else
        log_to_planning "FAILED" "Failed at: $PROMPT_NAME"
        exit 1
    fi
done

# Phase 2: Decomposition
echo ""
echo -e "${MAGENTA}â•â•â• PHASE 2: Task Decomposition â•â•â•${NC}"

for num in 06 06b; do
    prompt=$(find "$BUNDLE_PATH/prompts" -name "${num}*.md" 2>/dev/null | head -1)
    [[ -z "$prompt" ]] && continue
    
    PROMPT_NAME=$(basename "$prompt" .md)
    echo -e "${BLUE}â†’ $PROMPT_NAME${NC}"
    claude -p "$(cat "$prompt")" --allowedTools Edit,Write,Bash 2>&1 | tee "$FEATURE_DIR/${PROMPT_NAME}.log"
done

# Show review
echo ""
echo -e "${MAGENTA}â•â•â• TASK REVIEW â•â•â•${NC}"
[[ -f "$FEATURE_DIR/REVIEW.md" ]] && cat "$FEATURE_DIR/REVIEW.md"

# User decision
if [[ "$EXECUTE_SCOPE" == "review" ]]; then
    echo ""
    echo -e "${CYAN}Execute scope? [all/p0-p1/p0/none/custom:01,02]:${NC}"
    read -p "> " EXECUTE_SCOPE
    EXECUTE_SCOPE=${EXECUTE_SCOPE:-all}
fi

# Determine tasks
TASKS_TO_EXECUTE=""
TASKS_TO_DEFER=""

case "$EXECUTE_SCOPE" in
    all) TASKS_TO_EXECUTE="all" ;;
    p0-p1)
        TASKS_TO_EXECUTE=$(jq -r '.tasks[] | select(.priority == "P0" or .priority == "P1") | .id' "$FEATURE_DIR/tasks.json" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
        TASKS_TO_DEFER=$(jq -r '.tasks[] | select(.priority == "P2" or .priority == "P3") | "- Task \(.id): \(.name) [\(.priority)]"' "$FEATURE_DIR/tasks.json" 2>/dev/null)
        ;;
    p0)
        TASKS_TO_EXECUTE=$(jq -r '.tasks[] | select(.priority == "P0") | .id' "$FEATURE_DIR/tasks.json" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
        TASKS_TO_DEFER=$(jq -r '.tasks[] | select(.priority != "P0") | "- Task \(.id): \(.name) [\(.priority)]"' "$FEATURE_DIR/tasks.json" 2>/dev/null)
        ;;
    none)
        TASKS_TO_DEFER=$(jq -r '.tasks[] | "- Task \(.id): \(.name) [\(.priority)]"' "$FEATURE_DIR/tasks.json" 2>/dev/null)
        ;;
    custom:*)
        TASKS_TO_EXECUTE="${EXECUTE_SCOPE#custom:}"
        ;;
esac

# Handle deferred work
if [[ -n "$TASKS_TO_DEFER" ]]; then
    echo ""
    echo -e "${YELLOW}â•â•â• DEFERRED TASKS â•â•â•${NC}"
    echo "$TASKS_TO_DEFER"
    
    if [[ "$DEFER_ISSUE" == true ]]; then
        create_defer_issue "$FEATURE_DIR" "$TASKS_TO_DEFER"
    else
        echo ""
        read -p "Create GitHub issue for deferred tasks? [y/N]: " create_issue
        [[ "$create_issue" =~ ^[Yy] ]] && create_defer_issue "$FEATURE_DIR" "$TASKS_TO_DEFER"
    fi
fi

# Phase 3: Execute
if [[ -n "$TASKS_TO_EXECUTE" ]] && [[ "$TASKS_TO_EXECUTE" != "" ]]; then
    echo ""
    echo -e "${MAGENTA}â•â•â• PHASE 3: Execution â•â•â•${NC}"
    
    prompt=$(find "$BUNDLE_PATH/prompts" -name "07*.md" 2>/dev/null | head -1)
    [[ -n "$prompt" ]] && claude -p "$(cat "$prompt")" --allowedTools Edit,Write,Bash
    
    for task_prompt in "$FEATURE_DIR/prompts/"[0-9]*.md; do
        [[ ! -f "$task_prompt" ]] && continue
        TASK_ID=$(basename "$task_prompt" | grep -oE '^[0-9]+')
        
        if [[ "$TASKS_TO_EXECUTE" == "all" ]] || [[ ",$TASKS_TO_EXECUTE," == *",$TASK_ID,"* ]]; then
            echo -e "${BLUE}â†’ Task $TASK_ID${NC}"
            claude -p "$(cat "$task_prompt")" --allowedTools Edit,Write,Bash
            echo -e "${GREEN}âœ“${NC}"
        else
            echo -e "${YELLOW}âŠ˜ Skipped: Task $TASK_ID${NC}"
        fi
    done
fi

# Summary
echo ""
echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${GREEN}â•‘           COMPLETE                                           â•‘${NC}"
echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
echo "Session:  $SESSION_ID"
echo "Output:   $FEATURE_DIR/"
echo "Executed: ${TASKS_TO_EXECUTE:-none}"
[[ -n "$TASKS_TO_DEFER" ]] && echo "Deferred: $(echo "$TASKS_TO_DEFER" | grep -c "Task") tasks"
[[ -f "$FEATURE_DIR/DEFERRED_ISSUE.txt" ]] && echo "Issue:    $(cat "$FEATURE_DIR/DEFERRED_ISSUE.txt")"
echo ""

# Log to PLANNING.md (not LEDGER.md)
log_to_planning "COMPLETED" "**Output**: \`$FEATURE_DIR/\`

| Metric | Value |
|--------|-------|
| Executed | ${TASKS_TO_EXECUTE:-none} |
| Deferred | $(echo "$TASKS_TO_DEFER" | grep -c "Task" 2>/dev/null || echo 0) tasks |
$(if [[ -f "$FEATURE_DIR/DEFERRED_ISSUE.txt" ]]; then echo "| GitHub Issue | $(cat "$FEATURE_DIR/DEFERRED_ISSUE.txt") |"; fi)"

echo -e "${GREEN}Logged to .ai/ledger/PLANNING.md${NC}"
